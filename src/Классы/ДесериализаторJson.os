#Использовать annotations

#Область ОписаниеПеременных

// Лог
//
Перем Лог;

// Рефлектор
//
Перем Рефлектор;

// Множество - список известных пользовательских типов
//
Перем КэшИзвестныхТипов;

// Множество - список примитивных типов
//
Перем ПримитивныеТипы;

#КонецОбласти

#Область ПрограммныйИнтерфейс

// Десериализация JSON-строки в объект.
//
// Параметры:
//   Строка      - Строка - JSON-строка, которую необходимо десериализовать.
//                          Поддерживаются объекты, массивы и примитивы.
//   ТипОбъекта  - Тип     - Тип, в который нужно десериализовать JSON-строку (необязателен).
//   ЧитатьВСоответствие - Булево - если Истина, чтение нетипизированного объекта JSON будет выполнено в `Соответствие`.
//                                  Если Ложь, нетипизированные объекты будут считываться в объект типа `Структура`.
//                                  Значение по умолчанию: Ложь
// Возвращаемое значение:
//   Произвольный - Если тип не задан, возвращается значение, прочитанное платформенным методом ПрочитатьJSON;
//                  иначе преобразованный объект целевого типа.
//
Функция Десериализовать(Строка, ТипОбъекта = Неопределено, ЧитатьВСоответствие = Ложь) Экспорт
	
	ЧтениеJSON = Новый ЧтениеJSON();
	ЧтениеJSON.УстановитьСтроку(Строка);

	ДесериализованныйОбъект = ПрочитатьJSON(ЧтениеJSON, ЧитатьВСоответствие);

	// Если тип не задан - возвращаем прочитанный объект как есть
	Если ТипОбъекта = Неопределено Тогда
		Возврат ДесериализованныйОбъект;
	КонецЕсли;
	
	Объект = ПреобразоватьОбъектДесериализации(ДесериализованныйОбъект, ТипОбъекта);
	
	Возврат Объект;

КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Функция ПреобразоватьОбъектДесериализации(ДесериализованныйОбъект, ТипОбъекта)

	Если ЭтоПримитивныйТип(ТипОбъекта) Тогда
		Возврат ПреобразоватьПримитивныйТип(ДесериализованныйОбъект, ТипОбъекта);
	ИначеЕсли ТипОбъекта = Тип("Массив") Тогда
		Возврат ПреобразоватьМассив(ДесериализованныйОбъект, ТипОбъекта);
	ИначеЕсли ТипОбъекта = Тип("Соответствие") Тогда
		Возврат ПреобразоватьОбъект(ДесериализованныйОбъект, ТипОбъекта);
	ИначеЕсли ТипОбъекта = Тип("Структура") Тогда
		Возврат ПреобразоватьОбъект(ДесериализованныйОбъект, ТипОбъекта);
	ИначеЕсли ЭтоПользовательскийТип(ТипОбъекта) Тогда
		Возврат ПреобразоватьПользовательскийТип(ДесериализованныйОбъект, ТипОбъекта);
	Иначе
		Лог.Предупреждение("Неизвестный тип объекта: %1", ТипОбъекта);
	КонецЕсли;	

КонецФункции

Функция ЭтоПримитивныйТип(ТипОбъекта)
	Возврат ПримитивныеТипы.Содержит(ТипОбъекта);
КонецФункции

Функция ЭтоПользовательскийТип(ТипОбъекта)
	Возврат КэшИзвестныхТипов.Содержит(ТипОбъекта);
КонецФункции

Функция ПреобразоватьПримитивныйТип(Объект, ТипОбъекта)
	Возврат Объект;
КонецФункции

Функция ПреобразоватьМассив(Объект, ТипОбъекта)
	
	Результат = Новый Массив;

	Для Каждого Элемент Из Объект Цикл
		ПреобразованныйЭлемент = ПреобразоватьОбъектДесериализации(Элемент, ТипЗнч(Элемент));
		Результат.Добавить(ПреобразованныйЭлемент);
	КонецЦикла;

	Возврат Результат;

КонецФункции

Функция ПреобразоватьОбъект(Объект, ТипОбъекта)

	Результат = Новый(ТипОбъекта);

	Для Каждого КлючИЗначение Из Объект Цикл
		ПреобразованноеЗначение = ПреобразоватьОбъектДесериализации(КлючИЗначение.Значение, ТипЗнч(КлючИЗначение.Значение));
		Результат.Вставить(КлючИЗначение.Ключ, ПреобразованноеЗначение);
	КонецЦикла;

	Возврат Результат;

КонецФункции

Функция ПреобразоватьПользовательскийТип(Объект, ТипОбъекта)

	Результат = Новый(ТипОбъекта);
	СвойстваОбъекта = Рефлектор.ПолучитьТаблицуСвойств(ТипОбъекта, Истина);
	СвойстваПоИменамПолей = Новый Соответствие();

	Для Каждого Свойство Из СвойстваОбъекта Цикл
		АннотацияСериализуемое = РаботаСАннотациями.ПолучитьАннотацию(Свойство, "Сериализуемое");
		ИмяСвойства = РаботаСАннотациями.ПолучитьЗначениеПараметраАннотации(АннотацияСериализуемое, "Значение", Свойство.Имя);
		
		СвойстваПоИменамПолей.Вставить(ИмяСвойства, Свойство);
	КонецЦикла;

	Для Каждого КлючИЗначение Из Объект Цикл
		Свойство = СвойстваПоИменамПолей[КлючИЗначение.Ключ];
		Если Свойство = Неопределено Тогда
			// Если поле не найдено, то пропускаем его
			// TODO: Падать, если не висит @JsonIgnore
			Продолжить;
		КонецЕсли;

		ИмяСвойства = Свойство.Имя;
		ЗначениеСвойства = КлючИЗначение.Значение;
		ТипСвойства = ТипЗнч(ЗначениеСвойства);

		// Получаем тип из аннотации &Тип из библиотеки nixel2007/validate
		АннотацияТип = РаботаСАннотациями.ПолучитьАннотацию(Свойство, "Тип");
		Если АннотацияТип <> Неопределено Тогда
			ИмяТипа = РаботаСАннотациями.ПолучитьЗначениеПараметраАннотации(АннотацияТип, "Значение");
			ТипСвойства = Тип(ИмяТипа);
		КонецЕсли;

		ЗначениеСвойства = ПреобразоватьОбъектДесериализации(ЗначениеСвойства, ТипСвойства);
		Если ТипСвойства <> Неопределено И ТипСвойства <> ТипЗнч(ЗначениеСвойства) Тогда
			Лог.Ошибка("Тип свойства '%1' не соответствует ожидаемому типу '%2'", ТипЗнч(ЗначениеСвойства), ТипСвойства);
			Продолжить;
		КонецЕсли;

		Рефлектор.УстановитьСвойство(Результат, ИмяСвойства, ЗначениеСвойства);
	КонецЦикла;

	Возврат Результат;

КонецФункции

#КонецОбласти

Процедура ПриСозданииОбъекта()
	Лог = Логирование.ПолучитьЛог("oscript.lib.jason.ДесериализаторJson");
	Рефлектор = Новый Рефлектор();

	КэшИзвестныхТипов = Новый МножествоСоответствие;
	ИзвестныеТипы = Рефлектор.ИзвестныеТипы(Новый Структура("Пользовательский", Истина));
	Для Каждого ИзвестныйТип Из ИзвестныеТипы Цикл
		КэшИзвестныхТипов.Добавить(ИзвестныйТип.Значение);
	КонецЦикла;

	ПримитивныеТипы = Новый МножествоСоответствие;
	ПримитивныеТипы.Добавить(Тип("Строка"));
	ПримитивныеТипы.Добавить(Тип("Булево"));
	ПримитивныеТипы.Добавить(Тип("Дата"));
	ПримитивныеТипы.Добавить(Тип("Число"));
	ПримитивныеТипы.Добавить(Тип("Null"));
	ПримитивныеТипы.Добавить(Тип("Неопределено"));
КонецПроцедуры
