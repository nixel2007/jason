## Jason — JSON-сериализация для OneScript

Jason — библиотека на OneScript для сериализации и десериализации JSON.
Поддерживает примитивы, коллекции и пользовательские классы через аннотации и рефлексию.

- Пользовательские классы с поддержкой настроек сериализации через аннотации `&Сериализуемое` и `&Несериализуемое`
- Типизация полей для автоматической десериализации сложных объектов
- Коллекции: Массив, Структура, Соответствие (вложенные структуры поддерживаются)
- Совместимость: OneScript 2.0.0-rc.8+

### Установка

```bash
opm install jason
```

### Подключение и быстрый старт

```bsl
#Использовать jason
```

Сериализация:

```bsl
Сериализатор = Новый СериализаторJson();
JSON = Сериализатор.Сериализовать(Значение);
```

Десериализация (в пользовательский класс):

```bsl
Десериализатор = Новый ДесериализаторJson();
Объект = Десериализатор.Десериализовать(СтрокаJSON, Тип("ИмяКласса"));
```

Десериализация без указания типа (возвращает значение, прочитанное платформенным методом `ПрочитатьJSON`, без дополнительного преобразования):

```bsl
Десериализатор = Новый ДесериализаторJson();
Значение = Десериализатор.Десериализовать("[1, 2, {""a"": 3}]"); // Массив, вложенный объект как Структура (по умолчанию)

// Чтобы читать нетипизированные JSON-объекты как Соответствие, используйте третий параметр:
Значение2 = Десериализатор.Десериализовать("{""a"": 1}", Неопределено, Истина); // Соответствие
```

### Пользовательские классы и аннотации

Jason использует `annotations` для управления списком полей:

- `&Сериализуемое` — необязательная аннотация. По умолчанию все заполненные поля объекта сериализуются. Аннотация нужна для настройки:
	- `Значение` — имя свойства в JSON (переименование)
	- `Обязательное` — включать поле в JSON даже при значении Неопределено
- `&Несериализуемое` — исключает поле из сериализации

Пример класса (упрощённо):

```bsl
&Сериализуемое
Перем Строка;

// Поле будет включено в JSON даже без явного указания
Перем Число;
&Несериализуемое
// Поле не будет включено в JSON
Перем Временное;

&Сериализуемое("renamed_field")
 // Поле будет включено в JSON с именем renamed_field
Перем Переименованное;

&Сериализуемое(Обязательное = Истина)
// Поле будет включено в JSON, даже если оно не заполнено в объекте
Перем ОбязательноеПоле;
```

Имена свойств в JSON соответствуют именам полей (если явно не переименованы аннотацией &Сериализуемое). Поддерживаются кириллические имена.

### Поддерживаемые типы

- Примитивы: Число, Строка, Булево, Дата, Null/Неопределено
- Коллекции: Массив, Структура, Соответствие
- Пользовательские классы (через рефлексию и аннотации)

Особенности десериализации:
- JSON null читается как Неопределено.
- По умолчанию (без указания типа) JSON-объект читается как Структура.
- Внутри массива JSON-объекты по умолчанию будут иметь тип Структура (если не задан конкретный тип элемента).
- При передаче третьего параметра `ЧитатьВСоответствие = Истина` нетипизированные объекты читаются как Соответствие (и в корне, и внутри массивов).
- Если явно указать тип результата, например Тип("Структура"), то корневой JSON-объект будет приведён к Структуре.
- Если тип в вызове `Десериализовать` не указан, возвращается разобранное значение без приведения типов.

Сигнатура метода десериализации:

```bsl
Десериализатор.Десериализовать(СтрокаJSON, ТипОбъекта = Неопределено, ЧитатьВСоответствие = Ложь)
```

### Примеры

Сериализация структуры:

```bsl
Данные = Новый Структура("Имя, Возраст", "Тест", 25);
JSON = Новый СериализаторJson().Сериализовать(Данные);
```

Десериализация в класс:

```bsl
// ТестовыйКласс.os

&Сериализуемое("number")
Перем Число Экспорт; 

Перем Строка Экспорт;
```

```bsl
JSON = "{""Строка"":""значение"",""number"":10}";
Объект = Новый ДесериализаторJson().Десериализовать(JSON, Тип("ТестовыйКласс"));

Ожидаем.Что(Объект).ИмеетТип("ТестовыйКласс");
Ожидаем.Что(Объект.Строка).Равно("значение");
Ожидаем.Что(Объект.Число).Равно(10);
```

Больше примеров — в папке `tests/` (файлы `Сериализация.os`, `Десериализация.os`).

### Тесты

Тесты на OneUnit:

```bash
oneunit execute
```
### Лицензия

Этот проект лицензируется под лицензией MIT. Подробности см. в файле [LICENSE.md](./LICENSE.md).


